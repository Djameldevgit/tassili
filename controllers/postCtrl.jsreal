const mongoose = require('mongoose')
const Posts = require('../models/postModel')
const Comments = require('../models/commentModel')
const Users = require('../models/userModel')
const Vetement = require('../models/CategoriesModel/vetementModel')
const cloudinary = require('cloudinary').v2

// Configurar Cloudinary
cloudinary.config({
    cloud_name: 'dfjipgj2o',
    api_key: '213981915435275',
    api_secret: 'wv_IiCM9zzhdiWDNXXo8HZi7wX4'
})

class APIfeatures {
    constructor(query, queryString){
        this.query = query;
        this.queryString = queryString;
    }

    paginating(){
        const page = this.queryString.page * 1 || 1
        const limit = this.queryString.limit * 1 || 9
        const skip = (page - 1) * limit
        this.query = this.query.skip(skip).limit(limit)
        return this;
    }
}

const postCtrl = {
    
    createPost: async (req, res) => {
        try {
            const { postData, images } = req.body

            // âœ… SOLO 2 VALIDACIONES MÃNIMAS
            if (!images || images.length === 0) {
                return res.status(400).json({msg: "Veuillez ajouter au moins une photo."})
            }

            if (!postData.subCategory) {
                return res.status(400).json({msg: "La sous-catÃ©gorie est requise."})
            }

            // âœ… DETERMINAR EL MODELO ESPECÃFICO SEGÃšN CATEGORÃA
            let SpecificModel, modelRef
            
            switch(postData.category) {
                case 'vetements':
                    SpecificModel = Vetement // âœ… YA IMPORTADO
                    modelRef = 'vetement'
                    break
                case 'telefonos':
                    // SpecificModel = Telefono // â³ DESCOMENTA CUANDO CREES ESTE MODELO
                    SpecificModel = Vetement // â³ TEMPORAL
                    modelRef = 'telefonos'
                    break
                case 'vehiculos':
                    // SpecificModel = Vehiculo // â³ DESCOMENTA CUANDO CREES ESTE MODELO
                    SpecificModel = Vetement // â³ TEMPORAL
                    modelRef = 'vehiculos'
                    break
                default:
                    SpecificModel = Vetement
                    modelRef = 'vetements'
            }

            // âœ… CREAR MODELO ESPECÃFICO
            const newSpecific = new SpecificModel({
                ...postData,
                subCategoryType: postData.subCategory
            })
            
            const savedSpecific = await newSpecific.save()

            // âœ… CREAR POST BASE
            const newPost = new Posts({
                ...postData,
                images: images,
                user: req.user._id,
                [modelRef]: savedSpecific._id // âœ… REFERENCIA DINÃMICA
            })

            const savedPost = await newPost.save()

            // âœ… ACTUALIZAR REFERENCIA EN EL MODELO ESPECÃFICO
            await SpecificModel.findByIdAndUpdate(
                savedSpecific._id,
                { post: savedPost._id }
            )

            // âœ… POPULATE Y RESPUESTA
            await savedPost.populate('user', 'avatar username followers')
            await savedPost.populate(modelRef)

            res.json({
                msg: 'Post crÃ©Ã© avec succÃ¨s!',
                newPost: savedPost
            })

        } catch (err) {
            console.error('Error en createPost:', err)
            return res.status(500).json({msg: err.message})
        }
    },
 //parece buen mcotrolador 
 updatePost: async (req, res) => {
    try {
        const { postData, images } = req.body;

        console.log('ðŸ“¦ postData recibido:', Object.keys(postData)); // DEBUG

        // Validaciones
        if (!images || images.length === 0) {
            return res.status(400).json({msg: "Veuillez ajouter au moins une photo."});
        }

        // Encontrar post existente
        const existingPost = await Posts.findOne({_id: req.params.id, user: req.user._id})
            .populate('vetement');
        
        if (!existingPost) {
            return res.status(400).json({msg: "Post non trouvÃ© ou non autorisÃ©."});
        }

        console.log('ðŸ” Post encontrado:', existingPost.category);
        console.log('ðŸ” Vetement reference:', existingPost.vetement ? existingPost.vetement._id : 'NO VETEMENT');

        // âœ… DETERMINAR MODELO ESPECÃFICO (MISMA LÃ“GICA EXACTA QUE createPost)
        let SpecificModel, modelRef;
        
        switch(existingPost.category) { // â† USAR existingPost.category en lugar de postData.category
            case 'vetements':
                SpecificModel = Vetement; // â† DEBE ESTAR BIEN IMPORTADO
                modelRef = 'vetement';
                break;
            case 'telefonos':
                SpecificModel = Vetement; // Temporal
                modelRef = 'telefono';
                break;
            case 'vehiculos':
                SpecificModel = Vetement; // Temporal
                modelRef = 'vehiculo';
                break;
            default:
                SpecificModel = Vetement;
                modelRef = 'vetement';
        }

        console.log('ðŸŽ¯ Modelo especÃ­fico:', SpecificModel.modelName); // DEBUG
        console.log('ðŸŽ¯ Referencia:', modelRef);

        // Manejo de imÃ¡genes
        const oldImageIds = existingPost.images.map(img => img.public_id).filter(Boolean);
        const newImageIds = images.map(img => img.public_id).filter(Boolean);
        const deletedImageIds = oldImageIds.filter(id => !newImageIds.includes(id));

        for (const publicId of deletedImageIds) {
            try {
                await cloudinary.uploader.destroy(publicId);
            } catch (cloudinaryErr) {
                console.error('Error borrando imagen:', cloudinaryErr);
            }
        }

        // âœ… DEFINIR CAMPOS DEL POST BASE (SOLO ESTOS)
        const postBaseFields = [
            'title', 'description', 'content', 'price', 'tipodemoneda', 
            'tipoventa', 'telefono', 'etat', 'estado', 'category', 'subCategory'
        ];

        // âœ… SEPARAR DATOS
        const postUpdateData = {};
        const specificUpdateData = {};

        Object.keys(postData).forEach(key => {
            // Excluir campos inmutables
            if (['_id', 'user', 'createdAt', 'updatedAt', '__v'].includes(key)) return;
            
            if (postBaseFields.includes(key)) {
                // Va al Post base
                postUpdateData[key] = postData[key];
            } else {
                // TODO lo demÃ¡s va al modelo especÃ­fico
                specificUpdateData[key] = postData[key];
            }
        });

        console.log('ðŸ“ Campos para Post:', Object.keys(postUpdateData));
        console.log('ðŸ‘• Campos para Vetement:', Object.keys(specificUpdateData));

        // âœ… ACTUALIZAR MODELO ESPECÃFICO (VETEMENT)
        const specificId = existingPost[modelRef];
        console.log('ðŸ”‘ ID del modelo especÃ­fico:', specificId);

        if (specificId && Object.keys(specificUpdateData).length > 0) {
            console.log('ðŸ”„ Actualizando Vetement con:', specificUpdateData);
            await SpecificModel.findByIdAndUpdate(
                specificId,
                specificUpdateData,
                { new: true, runValidators: true }
            );
            console.log('âœ… Vetement actualizado');
        } else {
            console.log('âŒ No se actualizÃ³ Vetement - RazÃ³n:', 
                !specificId ? 'No hay specificId' : 'No hay campos para actualizar');
        }

        // âœ… ACTUALIZAR POST BASE
        const updatedPost = await Posts.findOneAndUpdate(
            {_id: req.params.id, user: req.user._id}, 
            {
                ...postUpdateData,
                images: images
            },
            { new: true, runValidators: true }
        );

        // âœ… POPULATE COMPLETO
        await updatedPost.populate('user', 'avatar username followers');
        await updatedPost.populate(modelRef);

        console.log('ðŸŽ‰ Post actualizado con populate:', updatedPost.vetement ? 'SÃ tiene vetement' : 'NO tiene vetement');

        res.json({
            msg: 'Post modifiÃ© avec succÃ¨s!',
            newPost: updatedPost
        });

    } catch (err) {
        console.error('âŒ Error en updatePost:', err);
        return res.status(500).json({msg: err.message});
    }
},


    // ðŸ”„ MANTENER TODOS TUS OTROS MÃ‰TODOS EXISTENTES
    getPosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find(), req.query).paginating()
            const posts = await features.query.sort('-createdAt')
                .populate('user', 'avatar username fullname followers')
                .populate('vetement')
                .populate('telefonos')
                .populate('vehiculos')

            res.json({
                msg: 'Success!',
                result: posts.length,
                posts
            })
        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },

  

    likePost: async (req, res) => {
        try {
            const post = await Posts.find({_id: req.params.id, likes: req.user._id})
            if(post.length > 0) return res.status(400).json({msg: "You liked this post."})

            const like = await Posts.findOneAndUpdate({_id: req.params.id}, {
                $push: {likes: req.user._id}
            }, {new: true})

            if(!like) return res.status(400).json({msg: 'This post does not exist.'})

            res.json({msg: 'Liked Post!'})

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
    unLikePost: async (req, res) => {
        try {

            const like = await Posts.findOneAndUpdate({_id: req.params.id}, {
                $pull: {likes: req.user._id}
            }, {new: true})

            if(!like) return res.status(400).json({msg: 'This post does not exist.'})

            res.json({msg: 'UnLiked Post!'})

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },

// âœ… NUEVO ENDPOINT PARA BÃšSQUEDA INTELIGENTE
// âœ… NUEVO CONTROLADOR PARA BÃšSQUEDA INTELIGENTE DE POSTS
// controllers/postCtrl.js
 

    getUserPosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find({user: req.params.id}), req.query)
            .paginating()
            const posts = await features.query.sort("-createdAt")

            res.json({
                posts,
                result: posts.length
            })

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
    getPost: async (req, res) => {
        try {
            const post = await Posts.findById(req.params.id)
                .populate("user likes", "avatar username followers")
                .populate({
                    path: "comments",
                    populate: {
                        path: "user likes",
                        select: "-password"
                    }
                });

            if (!post) return res.status(400).json({ msg: req.__('post.post_not_exist') });

            res.json({ post });
        } catch (err) {
            return res.status(500).json({ msg: err.message });
        }
    },


    viewPost: async (req, res) => {
        try {
            const { id } = req.params;

            if (!mongoose.Types.ObjectId.isValid(id)) {
                return res.status(400).json({ msg: 'ID invÃ¡lido' });
            }

            const postUpdated = await Posts.findByIdAndUpdate(
                id,
                { $inc: { views: 1 } },
                { new: true }
            )
                .populate("user likes", "avatar username followers")
                .populate({
                    path: "comments",
                    populate: {
                        path: "user likes",
                        select: "-password"
                    }
                });

            if (!postUpdated) return res.status(404).json({ msg: 'Post no encontrado' });

            res.json({ post: postUpdated }); // âœ… enviar post completo
        } catch (err) {
            return res.status(500).json({ msg: err.message });
        }
    },

    getPostsDicover: async (req, res) => {
        try {

            const newArr = [...req.user.following, req.user._id]

            const num  = req.query.num || 9

            const posts = await Posts.aggregate([
                { $match: { user : { $nin: newArr } } },
                { $sample: { size: Number(num) } },
            ])

            return res.json({
                msg: 'Success!',
                result: posts.length,
                posts
            })

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
     
    deletePost: async (req, res) => {
        try {
            const postId = req.params.id;
            const userId = req.user._id;
    
            // 1. VERIFICAR SI EL USUARIO ES EL DUEÃ‘O O ADMIN
            const post = await Posts.findById(postId);
            
            if (!post) {
                return res.status(404).json({msg: 'Post not found'});
            }
    
            if (post.user.toString() !== userId.toString() && req.user.role !== 'admin') {
                return res.status(403).json({msg: 'Not authorized to delete this post'});
            }
    
            console.log('ðŸ—‘ï¸ Eliminando post y sus imÃ¡genes:', post.images);
    
            // 2. BORRAR TODAS LAS IMÃGENES DEL POST DE CLOUDINARY
            if (post.images && post.images.length > 0) {
                for (const image of post.images) {
                    if (image.public_id) {
                        try {
                            await cloudinary.uploader.destroy(image.public_id);
                            console.log('âœ… Imagen borrada de Cloudinary:', image.public_id);
                        } catch (cloudinaryErr) {
                            console.error('âŒ Error borrando imagen de Cloudinary:', image.public_id, cloudinaryErr);
                            // Continuar aunque falle una imagen
                        }
                    }
                }
            }
    
            // 3. GUARDAR IDs DE COMMENTS Y LIKES ANTES DE ELIMINAR
            const commentsToDelete = post.comments || [];
            const likesToCleanup = post.likes || [];
    
            // 4. ELIMINAR EL POST DE MONGODB
            await Posts.findByIdAndDelete(postId);
    
            // 5. LIMPIAR DATOS RELACIONADOS
            if (commentsToDelete.length > 0) {
                await Comments.deleteMany({_id: {$in: commentsToDelete}});
            }
    
            // 6. OPCIONAL: Limpiar likes de usuarios
            if (likesToCleanup.length > 0) {
                await Users.updateMany(
                    {_id: {$in: likesToCleanup}},
                    {$pull: {likes: postId}}
                );
            }
    
            // 7. OPCIONAL: Eliminar de posts guardados
            await Users.updateMany(
                {saved: postId},
                {$pull: {saved: postId}}
            );
    
            res.json({
                msg: 'Post deleted successfully!',
                deletedPostId: postId,
                deletedImagesCount: post.images ? post.images.length : 0
            });
    
        } catch (err) {
            console.error('Error in deletePost:', err);
            return res.status(500).json({msg: err.message});
        }
    },

    savePost: async (req, res) => {
        try {
            const user = await Users.find({_id: req.user._id, saved: req.params.id})
            if(user.length > 0) return res.status(400).json({msg: "You saved this post."})

            const save = await Users.findOneAndUpdate({_id: req.user._id}, {
                $push: {saved: req.params.id}
            }, {new: true})

            if(!save) return res.status(400).json({msg: 'This user does not exist.'})

            res.json({msg: 'Saved Post!'})

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
    unSavePost: async (req, res) => {
        try {
            const save = await Users.findOneAndUpdate({_id: req.user._id}, {
                $pull: {saved: req.params.id}
            }, {new: true})

            if(!save) return res.status(400).json({msg: 'This user does not exist.'})

            res.json({msg: 'unSaved Post!'})

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
    getSavePosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find({
                _id: {$in: req.user.saved}
            }), req.query).paginating()

            const savePosts = await features.query.sort("-createdAt")

            res.json({
                savePosts,
                result: savePosts.length
            })

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
}

module.exports = postCtrl