const mongoose = require('mongoose')
const Posts = require('../models/postModel')
const Comments = require('../models/commentModel')
const Users = require('../models/userModel')
//const Vetement = require('../models/CategoriesModel/vetementModel')
const cloudinary = require('cloudinary').v2
 
const Vetement = require("../models/CategoriesModel/Vetement");
const Telefono = require("../models/CategoriesModel/Telefono");
const Vehiculo = require("../models/CategoriesModel/Vehiculo");
const { validatePostData } = require('./validators/postValidatorr')

 
const modelsByCategory = {
    vetements: { model: Vetement, ref: "vetement" },
    telefonos: { model: Telefono, ref: "telefono" },
    vehiculos: { model: Vehiculo, ref: "vehiculo" }
};

// Configurar Cloudinary
cloudinary.config({
    cloud_name: 'dfjipgj2o',
    api_key: '213981915435275',
    api_secret: 'wv_IiCM9zzhdiWDNXXo8HZi7wX4'
})

class APIfeatures {
    constructor(query, queryString){
        this.query = query;
        this.queryString = queryString;
    }

    paginating(){
        const page = this.queryString.page * 1 || 1
        const limit = this.queryString.limit * 1 || 9
        const skip = (page - 1) * limit
        this.query = this.query.skip(skip).limit(limit)
        return this;
    }
}

const postCtrl = {
    
   /* createPost: async (req, res) => {
        try {
            const { postData, images } = req.body

            // âœ… SOLO 2 VALIDACIONES MÃNIMAS
            if (!images || images.length === 0) {
                return res.status(400).json({msg: "Veuillez ajouter au moins une photo."})
            }

            if (!postData.subCategory) {
                return res.status(400).json({msg: "La sous-catÃ©gorie est requise."})
            }

            // âœ… DETERMINAR EL MODELO ESPECÃFICO SEGÃšN CATEGORÃA
            let SpecificModel, modelRef
            
            switch(postData.category) {
                case 'vetements':
                    SpecificModel = Vetement // âœ… YA IMPORTADO
                    modelRef = 'vetement'
                    break
                case 'telefonos':
                    // SpecificModel = Telefono // â³ DESCOMENTA CUANDO CREES ESTE MODELO
                    SpecificModel = Vetement // â³ TEMPORAL
                    modelRef = 'telefonos'
                    break
                case 'vehiculos':
                    // SpecificModel = Vehiculo // â³ DESCOMENTA CUANDO CREES ESTE MODELO
                    SpecificModel = Vetement // â³ TEMPORAL
                    modelRef = 'vehiculos'
                    break
                default:
                    SpecificModel = Vetement
                    modelRef = 'vetements'
            }

            // âœ… CREAR MODELO ESPECÃFICO
            const newSpecific = new SpecificModel({
                ...postData,
                subCategoryType: postData.subCategory
            })
            
            const savedSpecific = await newSpecific.save()

            // âœ… CREAR POST BASE
            const newPost = new Posts({
                ...postData,
                images: images,
                user: req.user._id,
                [modelRef]: savedSpecific._id // âœ… REFERENCIA DINÃMICA
            })

            const savedPost = await newPost.save()

            // âœ… ACTUALIZAR REFERENCIA EN EL MODELO ESPECÃFICO
            await SpecificModel.findByIdAndUpdate(
                savedSpecific._id,
                { post: savedPost._id }
            )

            // âœ… POPULATE Y RESPUESTA
            await savedPost.populate('user', 'avatar username followers')
            await savedPost.populate(modelRef)

            res.json({
                msg: 'Post crÃ©Ã© avec succÃ¨s!',
                newPost: savedPost
            })

        } catch (err) {
            console.error('Error en createPost:', err)
            return res.status(500).json({msg: err.message})
        }
    },
*/


 

    createPost: async (req, res) => {
        try {
            const { postData, images } = req.body;

            // 1ï¸âƒ£ ValidaciÃ³n externa
            const { isValid, errors } = validatePostData(postData);
            if (!isValid) return res.status(400).json({ errors });

            // 2ï¸âƒ£ Determinar modelo por categorÃ­a
            const categoryInfo = modelsByCategory[postData.category];
            if (!categoryInfo) {
                return res.status(400).json({ msg: "CategorÃ­a desconocida." });
            }

            const SpecificModel = categoryInfo.model;
            const modelRef = categoryInfo.ref;

            // 3ï¸âƒ£ Crear el documento especÃ­fico
            const specificItem = new SpecificModel({
                ...postData,   // campos propios de esa categorÃ­a
            });

            const savedSpecific = await specificItem.save();

            // 4ï¸âƒ£ Crear el Post principal
            const newPost = new Posts({
                user: req.user._id,
                ...postData,           // campos comunes
                images: images || [],  // imÃ¡genes fuera de postData
                [modelRef]: savedSpecific._id,  // referencia al modelo especÃ­fico
            });

            const savedPost = await newPost.save();

            // 5ï¸âƒ£ Actualizar el documento especÃ­fico con referencia al post
            await SpecificModel.findByIdAndUpdate(
                savedSpecific._id,
                { post: savedPost._id }
            );

            return res.json({
                msg: "Post creado con Ã©xito!",
                post: savedPost
            });

        } catch (err) {
            console.error(err);
            return res.status(500).json({ msg: err.message });
        }
    },
 
 









    // ðŸ”„ MANTENER TODOS TUS OTROS MÃ‰TODOS EXISTENTES
    getPosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find(), req.query).paginating()
            const posts = await features.query.sort('-createdAt')
                .populate('user', 'avatar username fullname followers')
                .populate('vetement')
                .populate('telefonos')
                .populate('vehiculos')

            res.json({
                msg: 'Success!',
                result: posts.length,
                posts
            })
        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },

    updatePost: async (req, res) => {
        try {
            const { postData, images } = req.body
            
            const post = await Posts.findOneAndUpdate({_id: req.params.id, user: req.user._id}, {
                ...postData,
                images: images || postData.images
            }, { new: true })

            if (!post) return res.status(400).json({msg: "Post non trouvÃ© ou non autorisÃ©."})

            // âœ… ACTUALIZAR TAMBIÃ‰N EL MODELO ESPECÃFICO SI EXISTE
            if (post.vetement) {
                const Vetement = require('../models/Vetement')
                await Vetement.findByIdAndUpdate(post.vetement, postData)
            }

            await post.populate('user', 'avatar username followers')
            await post.populate('vetement')

            res.json({
                msg: 'Post modifiÃ© avec succÃ¨s!',
                newPost: post
            })

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },

    likePost: async (req, res) => {
        try {
            const post = await Posts.find({_id: req.params.id, likes: req.user._id})
            if(post.length > 0) return res.status(400).json({msg: "You liked this post."})

            const like = await Posts.findOneAndUpdate({_id: req.params.id}, {
                $push: {likes: req.user._id}
            }, {new: true})

            if(!like) return res.status(400).json({msg: 'This post does not exist.'})

            res.json({msg: 'Liked Post!'})

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
    unLikePost: async (req, res) => {
        try {

            const like = await Posts.findOneAndUpdate({_id: req.params.id}, {
                $pull: {likes: req.user._id}
            }, {new: true})

            if(!like) return res.status(400).json({msg: 'This post does not exist.'})

            res.json({msg: 'UnLiked Post!'})

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },

// âœ… NUEVO ENDPOINT PARA BÃšSQUEDA INTELIGENTE
// âœ… NUEVO CONTROLADOR PARA BÃšSQUEDA INTELIGENTE DE POSTS
// controllers/postCtrl.js
 

    getUserPosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find({user: req.params.id}), req.query)
            .paginating()
            const posts = await features.query.sort("-createdAt")

            res.json({
                posts,
                result: posts.length
            })

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
    getPost: async (req, res) => {
        try {
            const post = await Posts.findById(req.params.id)
                .populate("user likes", "avatar username followers")
                .populate({
                    path: "comments",
                    populate: {
                        path: "user likes",
                        select: "-password"
                    }
                });

            if (!post) return res.status(400).json({ msg: req.__('post.post_not_exist') });

            res.json({ post });
        } catch (err) {
            return res.status(500).json({ msg: err.message });
        }
    },


    viewPost: async (req, res) => {
        try {
            const { id } = req.params;

            if (!mongoose.Types.ObjectId.isValid(id)) {
                return res.status(400).json({ msg: 'ID invÃ¡lido' });
            }

            const postUpdated = await Posts.findByIdAndUpdate(
                id,
                { $inc: { views: 1 } },
                { new: true }
            )
                .populate("user likes", "avatar username followers")
                .populate({
                    path: "comments",
                    populate: {
                        path: "user likes",
                        select: "-password"
                    }
                });

            if (!postUpdated) return res.status(404).json({ msg: 'Post no encontrado' });

            res.json({ post: postUpdated }); // âœ… enviar post completo
        } catch (err) {
            return res.status(500).json({ msg: err.message });
        }
    },

    getPostsDicover: async (req, res) => {
        try {

            const newArr = [...req.user.following, req.user._id]

            const num  = req.query.num || 9

            const posts = await Posts.aggregate([
                { $match: { user : { $nin: newArr } } },
                { $sample: { size: Number(num) } },
            ])

            return res.json({
                msg: 'Success!',
                result: posts.length,
                posts
            })

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
     
    deletePost: async (req, res) => {
        try {
            const postId = req.params.id;
            const userId = req.user._id;
    
            // 1. VERIFICAR SI EL USUARIO ES EL DUEÃ‘O O ADMIN
            const post = await Posts.findById(postId);
            
            if (!post) {
                return res.status(404).json({msg: 'Post not found'});
            }
    
            if (post.user.toString() !== userId.toString() && req.user.role !== 'admin') {
                return res.status(403).json({msg: 'Not authorized to delete this post'});
            }
    
            console.log('ðŸ—‘ï¸ Eliminando post y sus imÃ¡genes:', post.images);
    
            // 2. BORRAR TODAS LAS IMÃGENES DEL POST DE CLOUDINARY
            if (post.images && post.images.length > 0) {
                for (const image of post.images) {
                    if (image.public_id) {
                        try {
                            await cloudinary.uploader.destroy(image.public_id);
                            console.log('âœ… Imagen borrada de Cloudinary:', image.public_id);
                        } catch (cloudinaryErr) {
                            console.error('âŒ Error borrando imagen de Cloudinary:', image.public_id, cloudinaryErr);
                            // Continuar aunque falle una imagen
                        }
                    }
                }
            }
    
            // 3. GUARDAR IDs DE COMMENTS Y LIKES ANTES DE ELIMINAR
            const commentsToDelete = post.comments || [];
            const likesToCleanup = post.likes || [];
    
            // 4. ELIMINAR EL POST DE MONGODB
            await Posts.findByIdAndDelete(postId);
    
            // 5. LIMPIAR DATOS RELACIONADOS
            if (commentsToDelete.length > 0) {
                await Comments.deleteMany({_id: {$in: commentsToDelete}});
            }
    
            // 6. OPCIONAL: Limpiar likes de usuarios
            if (likesToCleanup.length > 0) {
                await Users.updateMany(
                    {_id: {$in: likesToCleanup}},
                    {$pull: {likes: postId}}
                );
            }
    
            // 7. OPCIONAL: Eliminar de posts guardados
            await Users.updateMany(
                {saved: postId},
                {$pull: {saved: postId}}
            );
    
            res.json({
                msg: 'Post deleted successfully!',
                deletedPostId: postId,
                deletedImagesCount: post.images ? post.images.length : 0
            });
    
        } catch (err) {
            console.error('Error in deletePost:', err);
            return res.status(500).json({msg: err.message});
        }
    },

    savePost: async (req, res) => {
        try {
            const user = await Users.find({_id: req.user._id, saved: req.params.id})
            if(user.length > 0) return res.status(400).json({msg: "You saved this post."})

            const save = await Users.findOneAndUpdate({_id: req.user._id}, {
                $push: {saved: req.params.id}
            }, {new: true})

            if(!save) return res.status(400).json({msg: 'This user does not exist.'})

            res.json({msg: 'Saved Post!'})

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
    unSavePost: async (req, res) => {
        try {
            const save = await Users.findOneAndUpdate({_id: req.user._id}, {
                $pull: {saved: req.params.id}
            }, {new: true})

            if(!save) return res.status(400).json({msg: 'This user does not exist.'})

            res.json({msg: 'unSaved Post!'})

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
    getSavePosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find({
                _id: {$in: req.user.saved}
            }), req.query).paginating()

            const savePosts = await features.query.sort("-createdAt")

            res.json({
                savePosts,
                result: savePosts.length
            })

        } catch (err) {
            return res.status(500).json({msg: err.message})
        }
    },
}

module.exports = postCtrl